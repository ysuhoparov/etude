Написать функцию перестановки 2-х чисел

1. С использованием указателей.  ( ptrswap )
2. С использованием ссылок.  ( refswap )

........................................



//принимает указатель на тип int, по которому размещены 10 переменных типа int.
//Функция ничего не возвращает, но по тому же указателю элементы  лежат в обратном порядке.


...........................................


Создайте функцию, которая принимает четыре параметра:
два массива с элементами, размеры массивов.
Функция возвращает массив уникальных элементов каждого массива, которых нет в другом массиве.

Например:
Массив 1      6,8,6,7,3
Массив 2      2,5,8,7,3

Результат:    6,2,5

...................................................

Треугольник Паскаля.

               1
           1  1  1
         1  2   2  1
       1  3   4   3  1


..........................................................

Числа Фибоначчи


...............................................................

Факториал

....................................................................

Реализация шифра Цезаря
//В древности для шифрования сообщений использовался такой способ : 
// все буквы в сообщении сдвигались на одно и то же число позиций в алфавите.
// Число позиций могло быть как положительным, так и отрицательным и являлось
//  параметром шифра.Если для сдвига на данное число позиций алфавита не хватает,
//  то он зацикливается(то есть буква с номером 27 — это снова буква «a», буква с
//  номером 28 — это «b» и так далее).
//
//Например, слово abracadabra при сдвиге на 10 позиций превратится в
//  klbkmknklbk.Этот простейший шифр называется шифром Цезаря.Регистр 
// букв(заглавные и строчные) менять не нужно.Напишите функцию encrypt_caesar
//  от строки и числа, которая возвращает исходную строку, зашифрованную шифром 
// Цезаря с параметром, равным данному числу.Также напишите функцию decrypt_caesar,
//  выполняющую обратное преобразование.Считаем, что входные строки состоят лишь из
//  английских букв; если там содержатся и другие символы, то их надо игнорировать.
//

//Пример 1
//The quick brown fox jumps over the lazy dog
//Ymj vznhp gwtbs ktc ozrux tajw ymj qfed it

.........................................................................

/*  5. Из обычных чисел — в римские
1 —I, 5 —V, 10 —X, 50 —L, 100 —C, 500 —D и 1000 —M */

........................................................................

/* Проход змейкой

Довольно абстрактная, но интересная задача. У нас есть двумерный массив целых чисел размером 5 на 5 элементов
. Его надо инициализировать и отобразить на экране. Особенность именно в способе этой инициализации.
Элементы должны быть инициализированы не последовательно, а змейкой. Т.е. в конце каждой строки мы не должны
переходить к первому элементу следующей строки, но начнём наоборот — с последнего элемента и так далее.
В итоге, в конечном отображении нашего массива числа должны быть упорядочены по возрастанию но змеевидно
от строки к строке. Сама же последовательность чисел — это простое линейное возрастание от 0 до 24, 
для её учёта можно завести отдельную переменную.

Попытайтесь решить эту задачу, используя минимальное количество временных переменных и без условных
переходов if. Если вы найдёте эту самую формулу индексации — будет замечательно! Предупреждаю, 
она может быть весьма витиеватая.
Итоговый результат:

0 1 2 3 4
9 8 7 6 5
10 11 12 13 14
19 18 17 16 15
20 21 22 23 24 */
.....................................................

Даётся массив целых чисел. Необходимо найти такие два индекса i и j в этом массиве,
что сумма a[i], a[i + 1], a[i + 2], … a[j] будет максимально возможной и вывести их.

Пример: a = { -2,1,-3,4,-1,2,1,-5,4 }

Тогда наибольшая сумма последовательных элементов находится между индексами 3 и 6 :

{4, -1, 2, 1}, сумма = 6. Необходимо вывести 3 и 6 */



/* Калькулятор

При запуске программа ожидает  пользовательского ввода во временную переменную строку. После ввода строки она распарсивается на  отдельные члены. Строка записывается в форме “<число-1><действие><число-2>” (без пробелов).
 Оба числа — это значения с плавающей точкой, повышенной точности (double).
 Действие может быть одним из: +, −, /, *. Результат действия выводится в стандартный вывод cout.

Рекомендации

Чтобы разделить полученную строку на отдельные элементы — числа и оператор, воспользуйтесь строковым потоком.
 Для этого создайте пустую строку std::string buffer и дайте пользователю возможность при помощи std::cin ввести
 в неё команду. Затем оберните полученную строку так: std::stringstream buffer_stream(buffer); Это позволит вам
 получить каждый из трёх компонентов команды: buffer_stream >> a >> operation >> b;
*/

....................

//принимаем указатель на char, по которому лежит строка.
//Функция должна возвращать true, если вторая строка является подстрокой первой

................................


Напишите рекурсивную функцию, которая принимает большое число n типа long long и переменную ans,
а возвращает void. После завершения работы функции в переменной ans должно оказаться количество
чётных цифр в записи числа n.
Пример:
int ans;
evendigits(9 223 372 036 854 775 806, ans);
ans == 10
Пояснение: 9 223 372 036 854 775 806



